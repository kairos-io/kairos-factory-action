name: Build Kairos Image

on:
  workflow_call:
    secrets:
      registry_username:
        required: false
      registry_password:
        required: false
    inputs:
      # Dockerfile path
      dockerfile_path:
        type: string
      
      # Kairos version for fallback Dockerfile
      kairos_version:
        type: string
        default: "v3.5.0"
        description: "Kairos version to use when downloading the fallback Dockerfile"
      
      # Core build parameters
      base_image:
        type: string
        default: "ubuntu:24.04"
      
      model:
        type: string
        default: "generic"
      
      arch:
        type: string
        default: "amd64"
      
      kubernetes_distro:
        type: string
        required: false
        description: "Kubernetes distribution to include. Must be either 'k0s' or 'k3s'. If not specified, no Kubernetes distribution will be included."
      
      kubernetes_version:
        type: string
        default: "auto"
      
      version:
        type: string
        required: true
      
      trusted_boot:
        type: boolean
        default: false
      
      # Individual artifact types
      iso:
        type: boolean
        default: false
      
      raw:
        type: boolean
        default: false
      
      vhd:
        type: boolean
        default: false
      
      gce:
        type: boolean
        default: false
      
      tar:
        type: boolean
        default: false

      # Checksums
      compute_checksums:
        type: boolean
        default: true
      
      output_format:
        type: string
        default: "auto"
      
      # Security and signing
      security_checks:
        type: string
        default: ""
      
      # Individual security checks
      cosign:
        type: boolean
        default: false
      
      grype:
        type: boolean
        default: false
      
      trivy:
        type: boolean
        default: false

      # SARIF generation and upload toggles
      grype_sarif:
        type: boolean
        default: false
      
      trivy_sarif:
        type: boolean
        default: false
      
      # Publishing
      registry_domain:
        type: string
        description: "Container registry domain to push to"
      
      registry_namespace:
        type: string
        description: "Namespace/organization in the registry URL"
      
      registry_repository:
        type: string
        required: false
        description: "Repository name in the registry (defaults to $FLAVOR if not specified)"
      
      # Output and reporting
      summary_artifacts:
        type: boolean
        default: false
      
      auroraboot_version:
        type: string
        default: "latest"
      
      # Custom tag format
      custom_tag_format:
        type: string
        required: false
        description: "Custom tag format using variables like $FLAVOR_RELEASE, $VARIANT, $ARCH, $MODEL, $VERSION, $KUBERNETES_DISTRO, $KUBERNETES_VERSION, $UKI, $COMMIT_SHA. If not provided, uses default format."
      
      custom_artifact_format:
        type: string
        required: false
        description: "Custom artifact filename format using variables like $FLAVOR_RELEASE, $VARIANT, $ARCH, $MODEL, $VERSION, $KUBERNETES_DISTRO, $KUBERNETES_VERSION, $UKI, $COMMIT_SHA. If not provided, uses auroraboot's default naming."

      custom_job_name_format:
        type: string
        required: false
        description: "Custom job name format using variables like $FLAVOR_RELEASE, $VARIANT, $ARCH, $MODEL, $VERSION, $KUBERNETES_DISTRO, $KUBERNETES_VERSION, $UKI, $COMMIT_SHA. If not provided, uses default format."
      
      image_labels:
        type: string
        required: false
        description: "Image labels to add to the image"
      
      # Trusted boot inputs
      keys_dir:
        type: string
        required: false
        description: "Path to directory containing trusted boot keys (required when trusted_boot is true)"
      
      sysext_dir:
        type: string
        required: false
        description: "Path to directory containing system extensions overlay (optional, only used when trusted_boot is true)"

      single_efi_cmdline:
        type: string
        required: false
        description: "Single EFI command line to use for trusted boot (optional, only used when trusted_boot is true)"
      
      # Cloud config (file path or URL)
      cloud_config:
        type: string
        required: false
        description: "Cloud-config file path or URL passed to auroraboot via --cloud-config. If empty, not passed."
      
      release:
        type: boolean
        default: false
        description: "Whether to create a GitHub release for the built artifacts"

      list_release_artifacts:
        type: boolean
        default: false
        description: "List all the artifacts that would be included in the release in the GitHub summary"

jobs:
  build:
    permissions:
      id-token: write  # OIDC support
      contents: write
      actions: read
      security-events: write
      models: none
    name: ${{ inputs.custom_job_name_format != '' && inputs.custom_job_name_format || format('{0}-{1}-{2}-{3}{4}{5}', inputs.base_image, (inputs.kubernetes_distro != '' && 'standard' || 'core'), inputs.arch, inputs.model, (inputs.kubernetes_distro != '' && format('-{0}', inputs.kubernetes_distro) || ''), (inputs.trusted_boot && '-uki' || '')) }}
    runs-on: ${{ inputs.arch == 'arm64' && 'ubuntu-24.04-arm' || 'ubuntu-24.04' }}
    steps:
      - name: Checkout source
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4
        with:
          fetch-depth: '0'

      - name: Validate inputs and setup Dockerfile
        shell: bash
        run: |
          # Create a temporary directory for downloaded files (needed for fallback cases)
          TEMP_DIR=$(mktemp -d)
          echo "üìÅ Created temporary directory: $TEMP_DIR"
          
          # Check if user provided a dockerfile_path
          if [[ -n "${{ inputs.dockerfile_path }}" ]]; then
            # User provided a path - validate it exists
            if [ ! -f "${{ inputs.dockerfile_path }}" ]; then
              echo "‚ùå Error: Dockerfile not found at ${{ inputs.dockerfile_path }}"
              echo "   Current directory: $(pwd)"
              echo "   Directory contents: $(ls -la)"
              echo "   Please ensure the Dockerfile exists at the specified path"
              exit 1
            fi
            echo "‚úÖ Found Dockerfile at ${{ inputs.dockerfile_path }}"
            echo "DOCKERFILE_PATH=${{ inputs.dockerfile_path }}" >> $GITHUB_ENV
          else
            # User didn't provide a path - download fallback
            echo "üì• No Dockerfile path provided, downloading fallback from Kairos ${{ inputs.kairos_version }}"
            
            # Download the default Kairos Dockerfile to temp directory
            echo "üì• Downloading default Kairos Dockerfile from https://github.com/kairos-io/kairos/blob/${{ inputs.kairos_version }}/images/Dockerfile"
            curl -L "https://raw.githubusercontent.com/kairos-io/kairos/${{ inputs.kairos_version }}/images/Dockerfile" -o "$TEMP_DIR/Dockerfile"
            
            if [ -f "$TEMP_DIR/Dockerfile" ]; then
              echo "‚úÖ Successfully downloaded default Dockerfile to $TEMP_DIR/Dockerfile"
              # Update the dockerfile_path to use the downloaded file
              echo "DOCKERFILE_PATH=$TEMP_DIR/Dockerfile" >> $GITHUB_ENV
            else
              echo "‚ùå Error: Failed to download default Dockerfile"
              exit 1
            fi
          fi
          
          # Download Dockerfile.img only if RAW builds are requested
          if [[ "${{ inputs.raw }}" == "true" ]]; then
            echo "üì• Downloading Kairos Dockerfile.img for RAW builds from https://github.com/kairos-io/kairos/blob/${{ inputs.kairos_version }}/images/Dockerfile.img"
            curl -L "https://raw.githubusercontent.com/kairos-io/kairos/${{ inputs.kairos_version }}/images/Dockerfile.img" -o "$TEMP_DIR/Dockerfile.img"
            
            if [ -f "$TEMP_DIR/Dockerfile.img" ]; then
              echo "‚úÖ Successfully downloaded Dockerfile.img to $TEMP_DIR/Dockerfile.img"
              # Update the dockerfile_img_path to use the downloaded file
              echo "DOCKERFILE_IMG_PATH=$TEMP_DIR/Dockerfile.img" >> $GITHUB_ENV
            else
              echo "‚ùå Error: Failed to download Dockerfile.img"
              exit 1
            fi
          fi
          
          # Validate required inputs
          if [[ -z "${{ inputs.version }}" ]]; then
            echo "‚ùå Error: version is required"
            exit 1
          fi
          
          # Validate kubernetes_distro values
          if [[ -n "${{ inputs.kubernetes_distro }}" ]]; then
            case "${{ inputs.kubernetes_distro }}" in
              k3s|k0s)
                ;;
              *)
                echo "‚ùå Error: kubernetes_distro must be 'k3s' or 'k0s'"
                exit 1
                ;;
            esac
          fi
          
          # Validate arch values
          case "${{ inputs.arch }}" in
            amd64|arm64)
              ;;
            *)
              echo "‚ùå Error: arch must be 'amd64' or 'arm64'"
              exit 1
              ;;
          esac
          
          echo "‚úÖ Input validation passed"



      - name: Setup environment
        id: setup
        shell: bash
        run: |
          # Determine variant based on kubernetes_distro
          if [[ -n "${{ inputs.kubernetes_distro }}" ]]; then
            VARIANT="standard"
          else
            VARIANT="core"
          fi
          
          # Handle version resolution
          if [[ "${{ inputs.version }}" == "auto" ]]; then
            VERSION=$(git describe --tags --dirty --always)
            # Handle three cases:
            # 1. No tags: 39d55d3 ‚Üí v0.0.0-39d55d3
            # 2. Dirty tag: v3.5.0-23-g94fe1d98 ‚Üí keep as is
            # 3. Clean tag: v3.5.0 ‚Üí keep as is
            if [[ "$VERSION" =~ ^[a-f0-9]+$ ]]; then
              # Just a commit SHA (no tags), prefix with v0.0.0-
              VERSION="v0.0.0-$VERSION"
            fi
          else
            VERSION="${{ inputs.version }}"
          fi
          echo "VERSION=$VERSION" >> $GITHUB_ENV

          if [[ "${{ inputs.kairos_version }}" == "auto" ]]; then
            KAIROS_VERSION=$VERSION
          elif [[ "${{ inputs.kairos_version }}" != "" ]]; then
            KAIROS_VERSION="${{ inputs.kairos_version }}"
          fi
          echo "KAIROS_VERSION=$KAIROS_VERSION" >> $GITHUB_ENV
          
          # Handle kubernetes version resolution
          if [[ "${{ inputs.kubernetes_version }}" == "auto" ]]; then
            KUBERNETES_VERSION=""
          else
            KUBERNETES_VERSION="${{ inputs.kubernetes_version }}"
          fi
          
          # Split base image for tag generation
          BASE_IMAGE=$(echo "${{ inputs.base_image }}" | cut -d ':' -f 1)
          BASE_TAG=$(echo "${{ inputs.base_image }}" | cut -d ':' -f 2 || echo 'latest')
          
          # Handle special cases for base images with slashes
          if [[ "$BASE_IMAGE" == *"/"* ]]; then
            DISTRO=$(echo "$BASE_IMAGE" | cut -d '/' -f 1)
            SUB_DISTRO=$(echo "$BASE_IMAGE" | cut -d '/' -f 2)
            FLAVOR="$DISTRO"
            FLAVOR_RELEASE="$SUB_DISTRO-$BASE_TAG"
          else
            FLAVOR="$BASE_IMAGE"
            FLAVOR_RELEASE="$BASE_TAG"
          fi
          
          # Special case for nvidia
          if [[ "${{ inputs.model }}" == "nvidia-jetson-agx-orin" ]]; then
            FLAVOR="ubuntu"
            FLAVOR_RELEASE="22.04"
          fi
          
          # Generate image tag
          # Replace + with - in kubernetes version for tag compatibility
          SANITIZED_KUBERNETES_VERSION=$(echo "$KUBERNETES_VERSION" | sed 's/+/-/g')
          
          # Set UKI suffix if trusted boot is enabled
          UKI_SUFFIX=""
          if [[ "${{ inputs.trusted_boot }}" == "true" ]]; then
            UKI_SUFFIX="-uki"
          fi
          
          # Define variables for tag generation
          ARCH="${{ inputs.arch }}"
          MODEL="${{ inputs.model }}"
          KUBERNETES_DISTRO="${{ inputs.kubernetes_distro }}"
          UKI="$UKI_SUFFIX"
          COMMIT_SHA="${{ github.sha }}"
          
          # Generate default tag
          if [[ -n "$KUBERNETES_VERSION" ]]; then
            DEFAULT_TAG="$FLAVOR_RELEASE-$VARIANT-$ARCH-$MODEL-$VERSION-$KUBERNETES_DISTRO-$SANITIZED_KUBERNETES_VERSION$UKI"
          else
            DEFAULT_TAG="$FLAVOR_RELEASE-$VARIANT-$ARCH-$MODEL-$VERSION$UKI"
          fi
          
          # Use custom tag format if provided, otherwise use default
          if [[ -n "${{ inputs.custom_tag_format }}" ]]; then
            # Shell will automatically expand variables in the format
            TAG="${{ inputs.custom_tag_format }}"
          else
            TAG="$DEFAULT_TAG"
          fi
          
          # Determine registry, namespace, and repository
          REGISTRY="${{ inputs.registry_domain }}"
          NAMESPACE="${{ inputs.registry_namespace }}"
          
          # Use registry_repository if specified, otherwise use FLAVOR
          if [[ -n "${{ inputs.registry_repository }}" ]]; then
            REPOSITORY="${{ inputs.registry_repository }}"
          else
            REPOSITORY="$FLAVOR"
          fi
          
          IMAGE_TAG=""
          # Build image tag
          if [[ -n "$REGISTRY" ]]; then
            IMAGE_TAG="$REGISTRY/"
          fi
          if [[ -n "$NAMESPACE" ]]; then
            IMAGE_TAG="$IMAGE_TAG$NAMESPACE/"
          fi
          if [[ -n "$REPOSITORY" ]]; then
            IMAGE_TAG="$IMAGE_TAG$REPOSITORY:"
          fi
          IMAGE_TAG="$IMAGE_TAG$TAG"

          echo "IMAGE_NAME=$IMAGE_TAG" >> $GITHUB_ENV
          
          # Generate artifact name
          if [[ -n "${{ inputs.custom_artifact_format }}" ]]; then
            # Shell will automatically expand variables in the format
            ARTIFACT_NAME="${{ inputs.custom_artifact_format }}"
          else
            # Generate default artifact name format
            DEFAULT_ARTIFACT_NAME="kairos-$FLAVOR_RELEASE-$VARIANT-$ARCH-$MODEL-$VERSION"
            
            # Append kubernetes distro and version if defined
            if [[ -n "$KUBERNETES_DISTRO" ]]; then
              DEFAULT_ARTIFACT_NAME="$DEFAULT_ARTIFACT_NAME-$KUBERNETES_DISTRO-$SANITIZED_KUBERNETES_VERSION"
            fi
            
            # Append UKI suffix if trusted boot is enabled
            DEFAULT_ARTIFACT_NAME="$DEFAULT_ARTIFACT_NAME$UKI"
            
            ARTIFACT_NAME="$DEFAULT_ARTIFACT_NAME"
          fi

          # Use keys_dir if specified
          if [[ -n "${{ inputs.keys_dir }}" ]]; then
            KEYS_DIR="${{ inputs.keys_dir }}"
          else
            KEYS_DIR=""
          fi

          # Use sysext_dir if specified
          if [[ -n "${{ inputs.sysext_dir }}" ]]; then
            SYSEXT_DIR="${{ inputs.sysext_dir }}"
          else
            SYSEXT_DIR=""
          fi

          # Use single_efi_cmdline if specified
          if [[ -n "${{ inputs.single_efi_cmdline }}" ]]; then
            SINGLE_EFI_CMDLINE="${{ inputs.single_efi_cmdline }}"
          else
            SINGLE_EFI_CMDLINE=""
          fi

          # Export variables
          echo "variant=$VARIANT" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "kubernetes_version=$KUBERNETES_VERSION" >> $GITHUB_OUTPUT
          echo "kubernetes_distro=$KUBERNETES_DISTRO" >> $GITHUB_OUTPUT
          echo "flavor=$FLAVOR" >> $GITHUB_OUTPUT
          echo "flavor_release=$FLAVOR_RELEASE" >> $GITHUB_OUTPUT
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "artifact_name=$ARTIFACT_NAME" >> $GITHUB_OUTPUT
          echo "keys_dir=$KEYS_DIR" >> $GITHUB_OUTPUT
          echo "sysext_dir=$SYSEXT_DIR" >> $GITHUB_OUTPUT
          echo "single_efi_cmdline=$SINGLE_EFI_CMDLINE" >> $GITHUB_OUTPUT
          
          echo "üîß Environment setup complete"
          echo "   Variant: $VARIANT"
          echo "   Version: $VERSION"
          echo "   Registry: $REGISTRY"
          echo "   Namespace: $NAMESPACE"
          echo "   Repository: $REPOSITORY"
          echo "   Default Tag: $DEFAULT_TAG"
          if [[ -n "${{ inputs.custom_tag_format }}" ]]; then
            echo "   Custom Tag Format: ${{ inputs.custom_tag_format }}"
          fi
          if [[ -n "${{ inputs.custom_artifact_format }}" ]]; then
            echo "   Custom Artifact Format: ${{ inputs.custom_artifact_format }}"
            echo "   Artifact Name: $ARTIFACT_NAME"
          fi
          if [[ -n "${{ inputs.keys_dir }}" ]]; then
            echo "   Keys Dir: ${{ inputs.keys_dir }}"
          fi
          if [[ -n "${{ inputs.sysext_dir }}" ]]; then
            echo "   Sysext Dir: ${{ inputs.sysext_dir }}"
          fi
          if [[ -n "${{ inputs.single_efi_cmdline }}" ]]; then
            echo "   Single EFI Cmdline: ${{ inputs.single_efi_cmdline }}"
          fi
          echo "   Final Tag: $TAG"
          echo "   Image Tag: $IMAGE_TAG"

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@master
        with:
          platforms: linux/${{ inputs.arch }}

      - name: Login to registry
        if: inputs.registry_domain != ''
        uses: docker/login-action@v3
        with:
          registry: ${{ inputs.registry_domain }}
          username: ${{ secrets.registry_username }}
          password: ${{ secrets.registry_password }}

      - name: Build Kairos image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ${{ env.DOCKERFILE_PATH }}
          platforms: linux/${{ inputs.arch }}
          push: false
          load: true
          tags: ${{ steps.setup.outputs.image_tag }}
          labels: ${{ inputs.image_labels }}
          build-args: |
            BASE_IMAGE=${{ inputs.base_image }}
            MODEL=${{ inputs.model }}
            KUBERNETES_VERSION=${{ steps.setup.outputs.kubernetes_version }}
            KUBERNETES_DISTRO=${{ inputs.kubernetes_distro }}
            TRUSTED_BOOT=${{ inputs.trusted_boot }}
            VERSION=${{ steps.setup.outputs.version }}

      - name: Run Grype security scan
        if: inputs.grype
        id: grype
        uses: anchore/scan-action@16910ac423301c6d30554b83a7f71ac6ff4a51f3 # v6.4.0
        with:
          image: ${{ steps.setup.outputs.image_tag }}
          output-format: json
          severity-cutoff: critical
          add-cpes-if-none: true
          only-fixed: true
          fail-build: false
      - name: Grype detailed check
        if: inputs.grype
        run: |
          # Check if the JSON file exists and is not empty
          if [[ ! -f "${{ steps.grype.outputs.json }}" ]] || [[ ! -s "${{ steps.grype.outputs.json }}" ]]; then
            echo "‚ùå Error: Grype JSON output file is missing or empty"
            echo "   Expected file: ${{ steps.grype.outputs.json }}"
            echo "   This indicates the Grype scan failed or didn't produce output"
            exit 1
          fi

          # Process the JSON file and check for critical vulnerabilities
          jq -r '.matches[] | select(.vulnerability.severity == "Critical") | "\(.vulnerability.id) \t \(.artifact.name) \(.artifact.version) -> \(.artifact.locations[]?.path // "no-path")"' "${{ steps.grype.outputs.json }}" | tee grype-critical.txt

          if [[ $(wc -l < grype-critical.txt) -gt 0 ]]; then
            echo "‚ùå Critical vulnerabilities found in the image. Failing the build."
            echo "   Vulnerabilities found:"
            cat grype-critical.txt
            exit 1
          else
            echo "‚úÖ No critical vulnerabilities found in the image."
          fi

      - name: Run Trivy security scan
        if: inputs.trivy
        uses: aquasecurity/trivy-action@76071ef0d7ec797419534a183b498b4d6366cf37 # 0.31.0
        with:
          image-ref: ${{ steps.setup.outputs.image_tag }}
          format: table
          severity: CRITICAL

      - name: Run Trivy SARIF scan
        if: inputs.trivy_sarif
        uses: aquasecurity/trivy-action@76071ef0d7ec797419534a183b498b4d6366cf37 # 0.31.0
        with:
          image-ref: ${{ steps.setup.outputs.image_tag }}
          format: sarif
          output: trivy.sarif
          severity: CRITICAL
          limit-severities-for-sarif: true

      - name: Generate Grype SARIF
        if: inputs.grype_sarif
        uses: anchore/scan-action@df395807f4554463d4455b8047cf58e37b6acaae # v6.5.0
        with:
          image: ${{ steps.setup.outputs.image_tag }}
          output-format: sarif
          output-file: grype.sarif
          severity-cutoff: critical
          add-cpes-if-none: true
          only-fixed: true

      - name: Filter Grype SARIF to critical
        if: inputs.grype_sarif
        uses: itxaka/sarif-filter@e5315c19bd49c5a4ad76310a2640b2586247d433 # v1
        with:
          input: grype.sarif
          output: grype.sarif
          severity: critical

      - name: Filter Trivy SARIF to critical
        if: inputs.trivy_sarif
        uses: itxaka/sarif-filter@e5315c19bd49c5a4ad76310a2640b2586247d433 # v1
        with:
          input: trivy.sarif
          output: trivy.sarif
          severity: critical

      - name: Upload Trivy scan results to GitHub Security tab
        if: inputs.trivy_sarif
        uses: github/codeql-action/upload-sarif@2d92b76c45b91eb80fc44c74ce3fce0ee94e8f9d # v3
        with:
          sarif_file: 'trivy.sarif'
          category: ${{ steps.setup.outputs.flavor }}-${{ steps.setup.outputs.flavor_release }}-${{ steps.setup.outputs.variant }}-${{ inputs.arch }}-${{ inputs.model }}${{ inputs.trusted_boot && '-uki' || '' }}

      - name: Upload Grype scan results to GitHub Security tab
        if: inputs.grype_sarif
        uses: github/codeql-action/upload-sarif@2d92b76c45b91eb80fc44c74ce3fce0ee94e8f9d # v3
        with:
          sarif_file: 'grype.sarif'
          category: ${{ steps.setup.outputs.flavor }}-${{ steps.setup.outputs.flavor_release }}-${{ steps.setup.outputs.variant }}-${{ inputs.arch }}-${{ inputs.model }}${{ inputs.trusted_boot && '-uki' || '' }}

      - name: Push Kairos image (build and push with SBOM)
        if: inputs.registry_domain != ''
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ${{ env.DOCKERFILE_PATH }}
          platforms: linux/${{ inputs.arch }}
          push: true
          sbom: true
          tags: ${{ steps.setup.outputs.image_tag }}
          labels: ${{ inputs.image_labels }}
          build-args: |
            BASE_IMAGE=${{ inputs.base_image }}
            MODEL=${{ inputs.model }}
            KUBERNETES_VERSION=${{ steps.setup.outputs.kubernetes_version }}
            KUBERNETES_DISTRO=${{ inputs.kubernetes_distro }}
            TRUSTED_BOOT=${{ inputs.trusted_boot }}
            VERSION=${{ steps.setup.outputs.version }}

      - name: Generate ISO artifact
        if: inputs.iso && inputs.model == 'generic'
        id: generate-iso
        shell: bash
        run: |
          echo "üîç Debug: Starting ISO generation step"
          echo "   Inputs: iso=${{ inputs.iso }}, model=${{ inputs.model }}"
          echo "   Image tag: ${{ steps.setup.outputs.image_tag }}"
          
          mkdir -p artifacts
          echo "   Using image: ${{ steps.setup.outputs.image_tag }}"

          echo "üì¶ Building ISO ..."
            DOCKER_CMD="docker run --rm -v /var/run/docker.sock:/var/run/docker.sock"
            DOCKER_CMD="$DOCKER_CMD -v $PWD/artifacts:/output"

            if [[ "${{ inputs.trusted_boot }}" == "true" ]]; then
              DOCKER_CMD="$DOCKER_CMD -v ${{ inputs.keys_dir }}:/keys"

              if [[ -n "${{ inputs.sysext_dir }}" ]]; then
                DOCKER_CMD="$DOCKER_CMD -v ${{ inputs.sysext_dir }}:/overlay"
              fi
            fi

            # Optional cloud-config (file path or URL)
            CLOUD_CONFIG_ARG=""
            CLOUD_CONFIG_INPUT="${{ inputs.cloud_config }}"
            if [[ -n "$CLOUD_CONFIG_INPUT" ]]; then
              if [[ "$CLOUD_CONFIG_INPUT" =~ ^https?:// ]]; then
                CLOUD_CONFIG_ARG="--cloud-config \"$CLOUD_CONFIG_INPUT\""
              else
                # Mount local file into container and refer to stable path
                if [[ "$CLOUD_CONFIG_INPUT" != /* ]]; then
                  ABS_CC_PATH="$PWD/$CLOUD_CONFIG_INPUT"
                else
                  ABS_CC_PATH="$CLOUD_CONFIG_INPUT"
                fi
                DOCKER_CMD="$DOCKER_CMD -v \"$ABS_CC_PATH\":/cloud-config:ro"
                CLOUD_CONFIG_ARG="--cloud-config /cloud-config"
              fi
            fi
            DOCKER_CMD="$DOCKER_CMD quay.io/kairos/auroraboot:${{ inputs.auroraboot_version }} --debug"
            if [[ "${{ inputs.trusted_boot }}" == "true" ]]; then
              DOCKER_CMD="$DOCKER_CMD build-uki"
            else
              DOCKER_CMD="$DOCKER_CMD build-iso"
            fi
            ## auroraboot flags
            if [[ "${{ inputs.trusted_boot }}" == "true" ]]; then
              DOCKER_CMD="$DOCKER_CMD --output-dir /output/"
            else
              DOCKER_CMD="$DOCKER_CMD --output /output/"
            fi

            if [[ "${{ inputs.trusted_boot }}" == "true" ]]; then
              DOCKER_CMD="$DOCKER_CMD --output-type=iso"
              DOCKER_CMD="$DOCKER_CMD --public-keys /keys"
              DOCKER_CMD="$DOCKER_CMD --tpm-pcr-private-key /keys/tpm2-pcr-private.pem"
              DOCKER_CMD="$DOCKER_CMD --sb-key /keys/db.key --sb-cert /keys/db.pem"

              if [[ -n "${{ inputs.single_efi_cmdline }}" ]]; then
                DOCKER_CMD="$DOCKER_CMD --single-efi-cmdline=\"${{ inputs.single_efi_cmdline }}\""
              fi

              if [[ -n "${{ inputs.sysext_dir }}" ]]; then
                DOCKER_CMD="$DOCKER_CMD --overlay-iso /overlay"
              fi
            fi

            # Append cloud-config flag if provided
            if [[ -n "$CLOUD_CONFIG_ARG" ]]; then
              DOCKER_CMD="$DOCKER_CMD $CLOUD_CONFIG_ARG"
            fi

            DOCKER_CMD="$DOCKER_CMD docker:${{ steps.setup.outputs.image_tag }}"
            
            echo "üîß Executing: $DOCKER_CMD"
            eval $DOCKER_CMD

          
          ISO_FILE=$(ls artifacts/*.iso | head -1)
          if [[ -n "$ISO_FILE" ]]; then
            echo "‚úÖ ISO generated: $ISO_FILE"
          else
            echo "‚ùå Error: No ISO file found in artifacts directory"
            echo "   Artifacts directory contents:"
            ls -la artifacts/ || echo "   Artifacts directory is empty or doesn't exist"
            exit 1
          fi

      - name: Generate RAW artifact
        if: inputs.raw
        id: generate-raw
        shell: bash
        run: |
          mkdir -p artifacts
          echo "üì¶ Building RAW artifact..."
          DOCKER_CMD="docker run --rm --privileged -v /var/run/docker.sock:/var/run/docker.sock"
          DOCKER_CMD="$DOCKER_CMD -v $PWD/artifacts:/output"

          # Optional cloud-config (file path or URL)
          CLOUD_CONFIG_ARG=""
          CLOUD_CONFIG_INPUT="${{ inputs.cloud_config }}"
          if [[ -n "$CLOUD_CONFIG_INPUT" ]]; then
            if [[ "$CLOUD_CONFIG_INPUT" =~ ^https?:// ]]; then
              CLOUD_CONFIG_ARG="--cloud-config \"$CLOUD_CONFIG_INPUT\""
            else
              if [[ "$CLOUD_CONFIG_INPUT" != /* ]]; then
                ABS_CC_PATH="$PWD/$CLOUD_CONFIG_INPUT"
              else
                ABS_CC_PATH="$CLOUD_CONFIG_INPUT"
              fi
              DOCKER_CMD="$DOCKER_CMD -v \"$ABS_CC_PATH\":/cloud-config:ro"
              CLOUD_CONFIG_ARG="--cloud-config /cloud-config"
            fi
          fi

          DOCKER_CMD="$DOCKER_CMD quay.io/kairos/auroraboot:${{ inputs.auroraboot_version }} --debug"
          if [[ -n "$CLOUD_CONFIG_ARG" ]]; then
            DOCKER_CMD="$DOCKER_CMD $CLOUD_CONFIG_ARG"
          fi
          DOCKER_CMD="$DOCKER_CMD --set \"disable_http_server=true\""
          DOCKER_CMD="$DOCKER_CMD --set \"disable_netboot=true\""
          DOCKER_CMD="$DOCKER_CMD --set \"container_image=docker:${{ steps.setup.outputs.image_tag }}\""
          DOCKER_CMD="$DOCKER_CMD --set \"state_dir=/output\""
          DOCKER_CMD="$DOCKER_CMD --set \"disk.raw=true\""

          echo "üîß Executing: $DOCKER_CMD"
          eval $DOCKER_CMD
          
          RAW_FILE=$(ls artifacts/*.raw | head -1)
          if [[ -n "$RAW_FILE" ]]; then
            echo "‚úÖ RAW generated: $RAW_FILE"
            echo "RAW_ARTIFACT=$RAW_FILE" >> $GITHUB_ENV
          else
            echo "‚ùå Error: No RAW file found in artifacts directory"
            echo "   Artifacts directory contents:"
            ls -la artifacts/ || echo "   Artifacts directory is empty or doesn't exist"
            exit 1
          fi

      - name: Create OCI artifact from RAW image
        if: inputs.raw
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ${{ env.DOCKERFILE_IMG_PATH }}
          platforms: linux/${{ inputs.arch }}
          push: true
          tags: ${{ steps.setup.outputs.image_tag }}-img
          build-args: |
            ARTIFACT=${{ env.RAW_ARTIFACT }}

      - name: Compute checksums for generated artifacts
        if: (inputs.iso || inputs.raw || inputs.vhd || inputs.tar) && inputs.compute_checksums
        shell: bash
        run: |
          mkdir -p artifacts
          if ls artifacts/*.{iso,raw,vhd,tar} 1> /dev/null 2>&1; then
            echo "üîç Computing SHA256 checksums"
            for f in artifacts/*.{iso,raw,vhd,tar}; do
              [ -f "$f" ] || continue
              sha256sum "$f" | tee "${f}.sha256"
            done
          else
            echo "‚ÑπÔ∏è  No artifact files found to checksum"
          fi

      - name: Generate VHD artifact
        if: inputs.vhd
        shell: bash
        run: |
          echo "üì¶ Building VHD artifact..."
          echo "‚ö†Ô∏è  VHD generation not yet implemented"

      - name: Generate GCE artifact
        if: inputs.gce
        shell: bash
        run: |
          echo "üì¶ Building GCE artifact..."
          echo "‚ö†Ô∏è  GCE generation not yet implemented"

      - name: Generate TAR artifact
        if: inputs.tar
        shell: bash
        run: |
          echo "üì¶ Building TAR artifact..."
          echo "‚ö†Ô∏è  TAR generation not yet implemented"

      - name: Install Cosign
        if: inputs.cosign
        uses: sigstore/cosign-installer@main

      - name: Sign image and artifact checksums with cosign
        if: inputs.cosign && inputs.registry_domain != ''
        env:
          COSIGN_YES: true
        shell: bash
        run: |
          set -euo pipefail
          
          echo "üîè Signing image in registry: ${{ steps.setup.outputs.image_tag }}"
          cosign sign ${{ steps.setup.outputs.image_tag }}

          echo "üîè Signing artifact checksums"
          for checksum in artifacts/*.sha256; do
            if [[ -f "$checksum" ]]; then
              cosign sign-blob --yes --output-certificate="${checksum}.pem" --output-signature="${checksum}.sig" "$checksum"
              echo "‚úÖ Signed checksum: $checksum"
            fi
          done

          if [[ -n "${{ env.RAW_ARTIFACT }}" ]]; then
            echo "üîè Signing RAW OCI image tag in registry: ${{ steps.setup.outputs.image_tag }}-img"
            cosign sign ${{ steps.setup.outputs.image_tag }}-img
          fi
      - name: GitHub Release
        if: inputs.release
        uses: softprops/action-gh-release@c95fe1489396fe8a9eb87c0abf8aa5b2ef267fda # v2.2.1
        with:
          files: |
            artifacts/*.iso
            artifacts/*.iso.sha256
            artifacts/*.iso.sha256.sig
      - name: List Release Artifacts
        if: inputs.list_release_artifacts
        shell: bash
        run: |
          echo "## üè≠ Kairos Factory Release Artifacts" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Artifacts:**" >> $GITHUB_STEP_SUMMARY
          for artifact in artifacts/*.iso artifacts/*.raw artifacts/*.vhd artifacts/*.tar; do
            if [[ -f "$artifact" ]]; then
              echo "- \`$(basename "$artifact")\`" >> $GITHUB_STEP_SUMMARY
            fi
          done

      - name: Generate GitHub summary
        if: inputs.summary_artifacts
        shell: bash
        run: |
          echo "## üè≠ Kairos Factory Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Image:** \`${{ steps.setup.outputs.image_tag }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Configuration:**" >> $GITHUB_STEP_SUMMARY
          echo "- Base Image: \`${{ inputs.base_image }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Model: \`${{ inputs.model }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Architecture: \`${{ inputs.arch }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Variant: \`${{ steps.setup.outputs.variant }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Version: \`${{ steps.setup.outputs.version }}\`" >> $GITHUB_STEP_SUMMARY
          
          if [[ -n "${{ inputs.kubernetes_distro }}" ]]; then
            echo "- Kubernetes: \`${{ inputs.kubernetes_distro }}\` \`${{ steps.setup.outputs.kubernetes_version }}\`" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [[ "${{ inputs.trusted_boot }}" == "true" ]]; then
            echo "- Trusted Boot: ‚úÖ Enabled" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Generated Artifacts:**" >> $GITHUB_STEP_SUMMARY
          
          ARTIFACT_COUNT=0
          for artifact in artifacts/*.iso artifacts/*.raw artifacts/*.vhd artifacts/*.tar; do
            if [[ -f "$artifact" ]]; then
              echo "- \`$(basename "$artifact")\`" >> $GITHUB_STEP_SUMMARY
              ARTIFACT_COUNT=$((ARTIFACT_COUNT + 1))
            fi
          done
          
          if [[ $ARTIFACT_COUNT -eq 0 ]]; then
            echo "- No artifacts generated" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [[ "${{ inputs.cosign }}" == "true" && "${{ inputs.registry_domain }}" != "" ]]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Security:**" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ Image signed with cosign" >> $GITHUB_STEP_SUMMARY
            # Check if any artifacts exist for signing
            if ls artifacts/*.iso artifacts/*.raw artifacts/*.vhd artifacts/*.tar 2>/dev/null | grep -q .; then
              echo "- ‚úÖ Artifacts signed with cosign" >> $GITHUB_STEP_SUMMARY
            fi
          elif [[ "${{ inputs.cosign }}" == "true" && "${{ inputs.registry_domain }}" == "" ]]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Security:**" >> $GITHUB_STEP_SUMMARY
            echo "- ‚ö†Ô∏è  Cosign signing skipped (requires registry_domain)" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Check which security scans were run
          SECURITY_SCANS=()
          if [[ "${{ inputs.grype }}" == "true" ]]; then
            SECURITY_SCANS+=("grype")
          fi
          if [[ "${{ inputs.trivy }}" == "true" ]]; then
            SECURITY_SCANS+=("trivy")
          fi
          
          if [[ ${#SECURITY_SCANS[@]} -gt 0 ]]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Security Scans:**" >> $GITHUB_STEP_SUMMARY
            for check in "${SECURITY_SCANS[@]}"; do
              echo "- ‚úÖ $check scan completed" >> $GITHUB_STEP_SUMMARY
            done
          fi

      - name: Upload ISO artifacts
        if: inputs.iso
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.setup.outputs.artifact_name }}.iso.zip
          path: |
            artifacts/*.iso
            artifacts/*.sha256
          if-no-files-found: error

      - name: Upload RAW artifacts
        if: inputs.raw
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.setup.outputs.artifact_name }}.raw.zip
          path: |
            artifacts/*.raw
            artifacts/*.sha256
          if-no-files-found: error
